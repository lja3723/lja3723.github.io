---
title: "[DB] 트랜잭션(Transaction)"
date: 2024-06-03 15:21:00 +0900
categories: [Computer-Science, DB]
tags: ['DB', 'SQL']
---



## 1. 트랜잭션(Transaction)

**Transaction(트랜잭션)**이란 DBMS에서 사용되는 작업의 단위로, 원자성, 일관성, 고립성, 지속성이라는 성질을 가진다. DBMS는 트랜잭션이 이러한 성질을 유지할 수 있도록 지원하여, DB의 안정성과 무결성을 보장한다.

- DB에서 트랜잭션을 정의하는 이유
  - 데이터베이스에서 데이터를 다룰 때 장애가 일어날 때 데이터를 복구하는 작업의 단위가 됨
  - 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때가 이 작업을 서로 분리하는 단위가 됨

- 트랜잭션은 **전체가 수행**되거나, **아니면 전혀 수행되지 않아야 함(all or nothing)**
- 보통 여러개의 SQL문으로 구성됨
- 예시: A계좌에서 B계좌로 10000원을 이체하는 경우

```sql
START TRANSACTION;
    -- ① A 계좌(박지성)에서 10,000원을 인출하는 UPDATE 문
    -- ② B 계좌(김연아)에 10,000원을 입금하는 UPDATE 문
COMMIT;
```

{% assign img_path = "/assets/img/posts/DB/2024-06-03-transaction" %}
![00tmp_1. 트랜잭션 1]({{ img_path }}/00tmp_1. 트랜잭션 1.png){: width='400'}
_temp img: 추후 정리 필요_

![00tmp_1. 트랜잭션 2]({{ img_path }}/00tmp_1. 트랜잭션 2.png){: width='400'}
_temp img: 추후 정리 필요_



## 2. 트랜잭션의 성질

### 2.1. 트랜잭션과 프로그램의 차이점

추가예정

### 2.2. 트랜잭션의 ACID 성질

- **원자성(Atomicity)**
  - 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 (all or nothing) 함
- **일관성(Consistency)**
  - 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
- **고립성(Isolation)**
  - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
- **지속성(Durability)**
  - 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함

#### 2.2.1. 원자성(Atomicity)

- 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미
- 일부만 수행되는 일이 없도록 전부 수행하거나 아예 수행하지 않아야(all or nothing) 함

| 표준 명령어       | MySQL 데이터베이스 문법       | 설명                                              |
| ----------------- | ----------------------------- | ------------------------------------------------- |
| START TRANSACTION | `SET TRANSACTION NAME <이름>` | 트랜잭션의 시작                                   |
| COMMIT            | `COMMIT`                      | 트랜잭션의 종료                                   |
| ROLLBACK          | `ROLLBACK {TO <savepoint>}`   | 트랜잭션을 전체 혹은 `<savepoint>`까지 무효화시킴 |
| SAVEPOINT         | `SAVEPOINT <savepoint>`       | `<savepoint>`를 만듬                              |

#### 2.2.2. 일관성(Consistency)

- 트랜잭션은 데이터베이스의 일관성을 유지해야 함
- 일관성은 테이블이 생성 시 CREATE 문과 ALTER 문의 무결성 제약조건을 통해 명시됨

![2.2.2. 일관성(Consistency)]({{ img_path }}/2.2.2. 일관성(Consistency).png){: width='500'}

#### 2.2.3. 고립성(Isolation)

- 데이터베이스는 공유가 목적이므로 여러 트랜잭션이 동시에 수행됨
- 동시에 수행되는 트랜잭션은 상호 존재를 모르고 독립적으로 수행되는데, 이를 고립성이라고 함
- 고립성을 유지하기 위해서는 트랜잭션이 변경 중인 임시 데이터를 다른 트랜잭션이 읽고 쓸 때 제어가 필요함

![2.2.3. 고립성(Isolation)]({{ img_path }}/2.2.3. 고립성(Isolation).png){: width='500'}

#### 2.2.4. 지속성(Durability)

- 트랜잭션이 정상적으로 완료(commit) 혹은 부분완료(partial commit)한 데이터는 DBMS가 책임지고 데이터베이스에 기록하는 성질

![2.2.4. 지속성(Durability)]({{ img_path }}/2.2.4. 지속성(Durability).png){: width='500'}

- 앞서 언급된 방법1과 방법2의 차이점은 다음과 같다.
  - 방법1: 지속성을 트랜잭션이 보장함
  - 방법2: 지속성을 DBMS가 보장함

### 2.3. 트랜잭션과 DBMS

- DBMS는 **원자성**을 유지하기 위해 회복(복구) 관리자 프로그램을 작동시킴
- DBMS는 **일관성**을 유지하기 위해 **무결성 제약조건을 활용**함
- DBMS는 **고립성**을 유지하기 위해 일관성을 유지하는 것과 마찬가지로 **동시성 제어 알고리즘을 작동**시킴
- DBMS는 **지속성**을 유지하기 위해 회복 관리자 프로그램을 이용함

![2.3. 트랜잭션과 DBMS]({{ img_path }}/2.3. 트랜잭션과 DBMS.png){: width='500'}



## 3. 동시성 제어

- **동시성 제어(concurrency control)**: 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능

|        | 트랜잭션1 | 트랜잭션2 | 발생 문제                                    | 동시접근                |
| ------ | --------- | --------- | -------------------------------------------- | ----------------------- |
| 상황 1 | 읽기      | 읽기      | 읽음(읽기만 하면 아무 문제가 없음)           | 허용                    |
| 상황 2 | 읽기      | 쓰기      | 오손 읽기, 반복불가능 읽기, 유령 데이터 읽기 | 허용 혹은 **불가** 선택 |
| 상황 3 | **쓰기**  | **쓰기**  | **갱신손실(절대 허용하면 안 됨)**            | **허용불가(LOCK 이용)** |

### 3.1. 갱신 손실 문제

- **갱신 손실(lost update**): 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(update)할 때 발생하며, **데이터베이스에서 절대 발생하면 안 되는 현상**

![3.1. 갱신 손실 문제 예]({{ img_path }}/3.1. 갱신 손실 문제 예.png){: width='500'}

- **작업 설명**
  - 한 개의 데이터에 두 개의 트랜잭션이 접근하여 갱신하는 작업

- **시나리오** 
  - 두 개의 트랜잭션이 동시에 작업을 진행

- **문제 발생: 갱신손실**
  - T2는 잘못된 데이터로 작업하여 잘못된 결과를 만든 다음, T1의 갱신 작업을 무효화하고 덧쓰기를 수행한 것임
  - 이때의 X 값인 1100은 어떤 트랜잭션에서도 의미가 없는 값
  - T1의 갱신이 손실된 갱신손실(lost update) 문제가 발생한 것임

갱신손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요하며, 데이터를 수정 중이라는 사실을 알리는 방법의 잠금 장치를 **락**이라고 한다.

### 3.2. 락

- **락**: 데이터를 수정 중이라는 사실을 알리는 방법의 잠금 장치

#### 3.2.1. 락을 이용한 갱신손실 문제 해결

![00tmp_3.2.1. 문제 해결]({{ img_path }}/00tmp_3.2.1. 문제 해결.png){: width='400'}
_temp img: 추후 정리 필요_

#### 3.2.2. 락의 개념

- **작업 설명**
  - 한 개의 데이터에 두 개의 트랜잭션이 접근하여 갱신하는 작업

![00tmp_3.2.2. 락의 개념 1]({{ img_path }}/00tmp_3.2.2. 락의 개념 1.png){: width='400'}
_temp img: 추후 정리 필요_

- **시나리오**
  - 두 트랜잭션을 동시에 실행

![00tmp_3.2.2. 락의 개념 2]({{ img_path }}/00tmp_3.2.2. 락의 개념 2.png){: width='400'}
_temp img: 추후 정리 필요_
![00tmp_3.2.2. 락의 개념 3]({{ img_path }}/00tmp_3.2.2. 락의 개념 3.png){: width='400'}
_temp img: 추후 정리 필요_

#### 3.2.3. 락의 유형

- **공유락(LS, shared lock)**
  - 트랜잭션이 읽기를 할 때 사용하는 락
- **배타락(LX, exclusive lock)**
  - 읽고 쓰기를 할 때 사용하는 락

- **공유락과 배타락을 사용하는 규칙**
  - 데이터에 락이 걸려있지 않으면 트랜잭션은 **데이터에 락을 걸 수 있음**
  - 트랜잭션이 데이터 X를 읽기만 할 경우 `LS(X)`를 요청하고, 읽거나 쓰기를 할 경우 `LX(X)`를 요청
  - 다른 트랜잭션이 데이터에 `LS(X)`을 걸어둔 경우, `LS(X)`의 요청은 허용하고 `LX(X)`는 허용하지 않음
  - 다른 트랜잭션이 데이터에 `LX(X)`을 걸어둔 경우, `LS(X)`와 `LX(X)` 모두 허용하지 않음
  - 트랜잭션이 락을 허용받지 못하면 대기 상태가 됨

- **락 호환행렬**

| 요청\상태 | LS 상태 | LX 상태 |
| :-------: | ------- | ------- |
|  LS 요청  | 허용    | 대기    |
|  LX 요청  | 대기    | 대기    |

### 3.3. 2단계 락킹

- **2단계 락킹 기법**
  - 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있어 이를 방지하는 방법
  - **확장단계(Growing phase, Expanding phase)**
    - 트랜잭션이 필요한 락을 획득하는 단계로, 이 단계에서는 이미 획득한 락을 해제하지 않음
  - **수축단계(Shrinking phase)**
    - 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않음.

- **작업 설명** 
  - 두 개의 데이터에 두 개의 트랜잭션이 접근하여 갱신하는 작업
- **문제 발생** 
  - 락을 사용하되 2단계 락킹 기법을 사용하지 않을 경우
- **문제 해결**
  - 2단계 락킹 기법을 사용할 경우

- **문제 발생**: 락을 사용하되 2단계 락킹 기법을 사용하지 않을 경우

![3.3. 2단계 락킹 문제 발생]({{ img_path }}/3.3. 2단계 락킹 문제 발생.png){: width='500'}

- **문제 해결**: 2단계 락킹 기법을 사용할 경우

![3.3. 2단계 락킹 문제 해결]({{ img_path }}/3.3. 2단계 락킹 문제 해결.png){: width='500'}

### 3.4. 데드락

- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대해 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상
  - 교착상태라고도 함
- **작업 설명**
  - 두 개의 데이터에 두 개의 트랜잭션이 접근하여 갱신하는 작업
- **문제 발생**
  - Oracle DBMS에서 데드락 발생
- **문제 해결**: 데드락 해결
  - 일반적으로 데드락이 발생하면 DBMS는 T1 혹은 T2의 **작업 중 하나를 강제로 중지**시킴
  - 그 결과 **나머지 트랜잭션은 정상적으로 실행됨**
  - 이때 중지시키는 트랜잭션에서 변경한 데이터는 원래 상태로 되돌려 놓음

<!-- omit from toc -->
#### **예시**
{: data-toc-skip=''}

![3.4. 데드락 예]({{ img_path }}/3.4. 데드락 예.png){: width='500'}

![3.4. 데드락 대기 그래프]({{ img_path }}/3.4. 데드락 대기 그래프.png){: width='500'}



## 4. 트랜잭션 고립 수준

### 4.1. 오손 읽기(dirty read)

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 **작업한 중간 데이터를 읽기 때문에** 생기는 문제
- 작업 중인 트랜잭션 2가 어떤 이유에서 작업을 **철회(ROLLBACK)할 경우** 트랜잭션 1은 **무효가 된 데이터**를 읽게 되고 잘못된 결과를 도출하는 현상
- 오손 읽기(dirty read)를 실험하기 위한 실습 테이블 생성

```sql
/* 실습 테이블 생성 */
Drop TABLE Users;

CREATE TABLE Users (
    id    INTEGER,
    name  VARCHAR2(20),
    age   NUMBER
);

INSERT INTO Users VALUES (1, 'HONG GILDONG', 30);

SELECT * FROM Users;

COMMIT;
```

- **작업 설명**
  - 두 개의 트랜잭션을 동시에 실행
  - 트랜잭션 T1, T2가 동시에 실행됨
  - T1은 읽기만 하고 T2는 쓰기를 함
  - T1은 T2가 변경한 데이터를 읽어와 작업하는데, T2가 작업 중 철회(ROLLBACK)를 하게 됨

- **문제 발생**: 오손 읽기
  - T2가 변경한 데이터를 T1이 읽은 후 어떤 원인으로 인하여 T2가 스스로 철회(ROLLBACK)를 하게 됨
  - 철회를 하면 T2의 작업은 없던 일이 됨
  - T1은 T2가 종료하지 않은 상태에서 T2가 변경한 데이터를 보고 작업을 하게 된 것임
  - 다음은 트랜잭션 T2가 홍길동의 나이를 30에서 21로 변경한 후 철회(ROLLBACK)하여, 트랜잭션 T1에게 오류를 발생시킨 예이다.

![4.1. 오손 읽기(dirty read)]({{ img_path }}/4.1. 오손 읽기(dirty read).png){: width='500'}

### 4.2. 반복불가능 읽기

- **반복불가능 읽기(non-repeatable read)**
  - 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(갱신, UPDATE) 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
  - 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과와 다른 결과가 나오는 현상

- **작업 설명** 
  - 두 개의 트랜잭션을 동시에 실행
  - 트랜잭션 T1, T2가 동시에 실행됨
  - T1은 읽기만 하고 T2는 쓰기(갱신, UPDATE)를 함
  - T1은 데이터를 읽고 작업을 한 후, T2가 변경한 데이터를 다시 한 번 읽어와 작업을 함
- **문제 발생**: 반복불가능 읽기
  - T1이 데이터를 읽고 작업하던 중 T2가 데이터를 변경함
  - T1은 변경한 데이터를 보고 다시 한 번 작업을 함
  - 오손 읽기와 달리 이번에는 T2가 COMMIT을 했기 때문에 틀린 데이터는 아님
  - T1 입장에서는 같은 SQL 문이 다른 결과를 도출한다.

![4.2. 반복불가능 읽기]({{ img_path }}/4.2. 반복불가능 읽기.png){: width='500'}

### 4.3. 유령데이터 읽기(phantom read)

- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(삽입) 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
- 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상

- **작업 설명** 
  - 두 개의 트랜잭션을 동시에 실행
  - 트랜잭션 T1은 읽기만 하고 T2는 쓰기(삽입, INSERT)를 함
  - T1은 데이터를 읽고 작업을 한 후, T2가 변경한 데이터를 다시 한 번 읽어와 작업을 함
- **문제 발생**: 유령데이터 읽기
  - T1이 T2가 새로운 데이터를 삽입한 사실을 모르고 작업을 함
  - T2가 COMMIT을 했기 때문에 틀린 데이터는 아님
  - 그러나 T1 입장에서는 새로운 데이터가 반영되어 반복불가능 읽기와 마찬가지로 같은 SQL 문이 다른 결과를 도출함
  - 유령데이터 읽기는 반복불가능 읽기와 비슷하지만 없던 데이터가 삽입되었기 때문에 다르게 구분함

> MySQL에서는 실습 불가능하다. 유령 데이터 읽기 현상이 발생하지 않기 때문
{: .prompt-warning}

![4.3. 유령데이터 읽기(phantom read)]({{ img_path }}/4.3. 유령데이터 읽기(phantom read).png){: width='500'}



## 5. 트랜잭션 고립 수준 명령어

- 트랜잭션 고립 수준 명령어(transaction isolation level instruction)
- DBMS는 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하기 위해 제공하는 명령어

![5. 트랜잭션 고립 수준 명령어]({{ img_path }}/5. 트랜잭션 고립 수준 명령어.png){: width='500'}

### 5.1. READ UNCOMMITTED(Level 0)

- 고립 수준이 가장 낮은 명령어로, 자신의 데이터에 아무런 공유락을 걸지 않음

(배타락은 갱신손실 문제 때문에 걸어야 한다). 또한 다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽는다. 심지어 다른 트랜잭션이 COMMIT하지 않은 데이터도 읽을 수 있다. 그 때문에 오손(dirty) 페이지의 데이터를 읽게 된다. 이 명령어는 SELECT 질의의 대상이 되는 테이블에 대해서 락을 설정하지 않은 것(NOLOCK)과 같다.

- **절대 사용하지 않음**

| **모드** | READ UNCOMMITTED |
| **LOCK** | SELECT 문 - 공유락 걸지 않음<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션의 공유락과 배타락이 걸린 데이터를 읽음 |
| **SQL 문** | SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED |
| **문제점** | 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 |

### 5.2. READ COMMITTED(Level 1)

- 오손(dirty) 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지 가능함.

다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행한다. 이 옵션은 오라클의 기본 설정으로 아무런 설정을 하지 않으면 READ COMMITTED 방식으로 수행된다.

- **가장 많이 쓰이는 모드**
- Level 2부터는 거의 쓰이지 않음

| **모드** | READ UNCOMMITTED |
| **LOCK** | SELECT 문 - 공유락을 걸고 끝나면 바로 해지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| **SQL 문** | SET TRANSACTION ISOLATION LEVEL READ COMMITTED |
| **문제점** | 반복불가능 읽기, 유령데이터 읽기 |

### 5.3. REPEATABLE READ(Level 2)

- 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(UPDATE)할 수 없도록 함.

다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행한다. 다른 고립화 수준에 비해 데이터의 **동시성(concurrency)이 낮아** 특별하지 않은 상황이라면 **사용하지 않는 것이 좋다.**

| **모드** | REPEATABLE READ |
| **LOCK** | SELECT 문 - 공유락을 걸고 트랜잭션을 끝까지 유지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함 |
| **SQL 문** | SET TRANSACTION ISOLATION LEVEL REPEATABLE READ |
| **문제점** | 유령데이터 읽기 |

### 5.4. SERIALIZABLE(Level 3)

- 고립 수준이 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.

데이터 집합에 범위를 지어 잠금을 설정할 수 있기 때문에 다른 사용자가 데이터를 변경하려고 할 때 트랜잭션을 완벽하게 분리할 수 있다. 이 명령어는 네 가지 고립화 수준 중 제한이 가장 심하고 데이터의 동시성도 낮다. 이 명령어는 SELECT 질의의 대상이 되는 테이블에 미리 배타락을 설정한 것과 같은 효과를 낸다.

| **모드** | SERIALIZABLE |
| **LOCK** | SELECT 문 - 공유락을 걸고 트랜잭션을 끝까지 유지<br>UPDATE 문 - 배타락 설정<br>다른 트랜잭션이 설정한 공유락은 읽지만 배타락은 읽지 못함<br>인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT 문이 금지됨 |
| **SQL 문** | SET TRANSACTION ISOLATION LEVEL SERIALIZABLE |
| **문제점** | 없음 |

> level 0 ~ level 3의 차이점을 잘 기억하자. 달달 외우지 말고 변화되는 점을 캐치하자.
{: .prompt-tip}


## 6. 회복(Recorvery)

- 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능

### 6.1. DB 시스템에서 발생할 수 있는 장애 유형

- **시스템 충돌**
  - 하드웨어 혹은 소프트웨어의 오류로 인하여 주기억장치가 손실되는 것을 말한다. 주기억장치에 상주하여 처리중인 프로그램과 데이터의 일부 혹은 전부가 손실된다.
- **미디어 장애**
  - 헤드의 충돌이나 읽기 장애에 의하여 보조기억장치의 일부 데이터가 손실되는 것을 말한다. 보조기억장치에 저장 중인 데이터의 일부 혹은 전부가 손실된다.
- **응용 소프트웨어 오류**
  - 데이터베이스에 접근하는 소프트웨어의 논리적인 오류로 트랜잭션의 수행이 실패하는 것을 말한다.
- **자연재해**
  - 화재, 홍수, 지진, 정전 등에 의해 컴퓨터 시스템이 손상되는 것을 말한다.
- **부주의 혹은 태업(sabotage)**
  - 운영자나 사용자의 부주의로 데이터가 손실되거나 의도적인 손상을 입는 것을 말한다.

### 6.2. 회복과 트랜잭션

![6.2. 회복과 트랜잭션 1]({{ img_path }}/6.2. 회복과 트랜잭션 1.png){: width='500'}
![6.2. 회복과 트랜잭션 2]({{ img_path }}/6.2. 회복과 트랜잭션 2.png){: width='500'}

### 6.3. 로그 파일

- 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 데이터베이스 기록을 추적하는 로그 파일(log file)을 사용함

- **로그 파일**
  - 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스로, 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 남아 있음
- **로그 파일에 저장된 로그의 구조**
  - <트랜잭션번호, 로그의 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>
- ‘로그의 타입’은 트랜잭션의 연산 타입으로 START, INSERT, UPDATE, DELETE,
ABORT, COMMIT 등이 있다. ‘수정 전 값’은 데이터의 변경 전 값을 나타내고, ‘수정 후 값’은 연산의 결과로 변경된 값을 나타냄

```sql
<T1, START>
<T1, UPDATE, Customer(박지성).balance, 100000, 90000>
<T1, UPDATE, Customer(김연아).balance, 100000, 110000>
<T1, COMMIT>
```

![6.3. 로그 파일]({{ img_path }}/6.3. 로그 파일.png){: width='500'}

#### 6.3.1. 로그 파일을 이용한 회복

- **데이터의 변경 기록**을 저장해 둔 로그 파일을 이용하면 시스템 장애도 복구할 수 있음
  - 아래 두 개의 트랜잭션이 실행된다고 하자. 편의상 트랜잭션의 연산 SELECT, UPDATE는 read_item( ), write_item( )으로 대체한다. 트랜잭션은 각각 데이터 A, B, C, D를 읽거나 쓰는 작업을 진행한다. 데이터(A, B, C, D)의 초깃값은 (100, 200, 300, 400)이다.

> write가 된 시점 순서로 로그파일은 저장된다. 버퍼에 적용되는 그 시점에 로그파일에 저장된다!
{: .prompt-warning}

![6.3.1. 로그 파일을 이용한 회복 1]({{ img_path }}/6.3.1. 로그 파일을 이용한 회복 1.png){: width='500'}

- 트랜잭션이 T1 → T2 순으로 실행된다면 다음과 같은 로그 파일이 생성된다.

![6.3.1. 로그 파일을 이용한 회복 2]({{ img_path }}/6.3.1. 로그 파일을 이용한 회복 2.png){: width='500'}

- 시스템 운영 중 장애가 발생하여 시스템이 다시 가동되었을 때 DBMS는 로그 파일을 먼저 살펴본다.
- DBMS는 트랜잭션이 종료되었는지 혹은 중단되었는지 여부를 판단하여 종료된 트랜잭션은 종료를 확정하기 위하여 재실행(REDO)을 진행하고, 중단된 트랜잭션은 없던 일로 되돌리기 위해 취소(UNDO)를 진행한다.

> 
{: .prompt-}

- **트랜잭션의 재실행(REDO)**

장애가 발생한 후 시스템을 다시 가동을 했을 때, 로그 파일에 트랜잭션 시작(START)이 있고 종료(COMMIT)가 있는 경우다. COMMIT 연산이 로그에 있다는 것은 트랜잭션이 모두 완료되었다는 의미다. 다만 변경 내용이 버퍼에서 데이터베이스에 기록되지 않았을 가능성이 있다. 따라서 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정이 필요하다. 이 과정을 **REDO**라고 한다.

- **트랜잭션의 취소(UNDO)**

장애가 발생한 후 시스템을 다시 가동했을 때, **로그 파일에 트랜잭션의 시작(START)만 있고 종료(COMMIT)가 없는 경우**다. **COMMIT 연산이 로그에 보이지 않는다는 것은 트랜잭션이 완료되지 못했다는 의미**로, 트랜잭션이 한 일을 모두 취소해야 한다. 이 경우 완료하지 못했지만 버퍼의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시켜야 한다. 이 과정을 **UNDO**라고 한다.

#### 6.3.2. 즉시 갱신 방법

즉시 갱신(immediate update)은 ‘갱신 데이터→로그’, ‘버퍼→데이터베이스’ 작업이 부분완료 전에 동시에 진행될 수 있으며, 부분완료가 되면 갱신 데이터는 로그에 기록이 끝난 상태

아래는 로그파일을 열었는데 (마지막 로그 번호 = i)가 몇인 경우 DBMS가 어떤 행동을 해야하는 지 도식화한 것이다.

- 업데이트 할때마다 버퍼에 저장하므로, 1 <= i <= 4 인 경우 T1을 UNDO해야할 필요가 있음

![6.3.2. 즉시갱신방법]({{ img_path }}/6.3.2. 즉시갱신방법.png){: width='500'}
_즉시 갱신 방법_

#### 6.3.3. 지연 갱신 방법

지연 갱신(deferred update)은 ‘갱신 데이터→로그’가 끝난 후 부분완료를 하고 ‘버퍼→데이터베이스’ 작업이 진행되는 방법

- 지연갱신은 커밋 끝날때까지 버퍼에 아무런 데이터를 저장 하지 않으므로, 저장 데이터가 아무 것도 없으니까 1 <= i <= 4 인 경우에는 아무 작업이 필요 없음

![6.3.3. 지연갱신방법]({{ img_path }}/6.3.3. 지연갱신방법.png){: width='500'}
_지연 갱신 방법_



### 6.4. 체크포인트를 이용한 회복

- 로그를 이용한 회복은 시스템에 장애가 일어났을 때 어느 시점까지 되돌아가야 하는지 알 수 없다. 트랜잭션이 많은 응용의 경우 하루 이상 되돌아가서 복구하는 것은 사실상 불가능하다.

- 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위하여 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법 혹은 그 시점을 체크포인트(혹은 검사점)라고 한다.
- 체크포인트 시점에는 다음과 같은 작업을 진행한다.

  - 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장한다.
  - 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장한다.
  - 체크포인트를 로그 파일에 표시한다.

- 체크포인트 때 하드디스크에 싹 밀어넣으므로, redo할지 안할지 고민할 필요가 없음(체크포인트 없었으면 버퍼에 기록되었음은 알지만 실제로 하드에 기록됐는지 확정할 수 없음)

- 체크포인트가 있으면 로그를 이용한 회복 기법은 좀더 간단해짐

- **체크포인트 이전에 `[COMMIT]` 기록이 있는 경우**

  - 아무 작업이 필요 없음. 로그에 체크포인트가 나타나는 시점은 이미 변경 내용이 데이터베이스에 모두 기록된 후이기 때문.

- **체크포인트 이후에 `[COMMIT]` 기록이 있는 경우**

  - REDO(T)를 진행. 체크포인트 이후에 변경 내용이 데이터베이스에 반영되지 않았으므로 REDO를 진행.

- **체크포인트 이후에 `[COMMIT]` 기록이 없는 경우**

  - 끝이 어딘지 모르므로 UNDO
  - 즉시 갱신 방법을 사용했다면 **UNDO(T)**를 진행. 버퍼의 내용이 반영됐을 수도 있기 때문에 원상복구 시켜야 함. 반면 지연 갱신 방법을 사용했다면 아무것도 할 필요가 없음. 지연 갱신 방법은 `[COMMIT]` 이전에는 버퍼의 내용을 데이터베이스에 반영하지 않기 때문

#### 6.4.1. 예시

- **즉시 갱신 방법**을 사용한 경우
  -  T2, T3: 아무 작업이 필요 없음
  -  T4, T5: REDO 필요
  -  **T1, T6는 UNDO가 필요**
- **지연 갱신 방법**을 사용한 경우
  - T2, T3는 아무 작업이 필요 없음
  - T4, T5: REDO 필요
  - T1, T6는 아무 작업이 필요없음

![6.4.1. 예시 1]({{ img_path }}/6.4.1. 예시 1.png){: width='500'}

- 트랜잭션 T1, T2, T3가 동시에 실행된 후 다음과 같이 로그 기록을 남겼다. 즉시 갱신 기법을 사용하여 회복을 한다면 REDO(T2), UNDO(T3)가 진행된다. T1에 대해서는 아무 작업이 필요 없음

![6.4.1. 예시 2]({{ img_path }}/6.4.1. 예시 2.png){: width='500'}

요약: 

- 커밋 기록 있으면 redo
- 커밋 기록 없으면 undo, 지연방식이었으면 아무것도 할 필요 없음