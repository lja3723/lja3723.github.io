---
title: "[OS] 스케줄링 알고리즘"
date: 2024-04-10 15:40:00 +0900
categories: [Computer-Science, OS]
tags: ['OS', '스케줄링']
---



## 1. 평가 기준

### 1.1. 대기 시간(Waiting Time)

- 프로세스가 준비 큐 내에서 대기하는 시간의 총 합

### 1.2. 반환 시간(Turn-around Time)

- 프로세스가 시작해서 끝날 때까지 걸리는 시간

### 1.3. 기타 기준

- **응답 시간(Response Time)**: '**첫번째**' 응답이 오기 시작할 때까지의 시간
- **CPU 사용률(CPU Utilization)**: 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
- **처리량(Throughput)**: CPU가 단위 시간당 처리하는 프로세스의 개수

### 1.4. **평균 대기시간**, 평균 반환시간

- 모든 프로세스의 대기/반환 시간을 합한 뒤 프로세스의 수로 나눈 값
  -  일반적으로 **이들이 빨라야 좋은 알고리즘**이다.

#### **예시**
{: data-toc-skip=''}

{% assign img_path = "/assets/img/posts/OS/2024-04-10-scheduling-algorithm" %}
![]({{ img_path }}/1.4. 평균 대기시간, 평균 반환시간.png){: width='300'}

![]({{ img_path }}/1.4. 평균 대기시간, 평균 반환시간 2.png){: width='450'}

**평균 대기시간**

> (대기 시간) = (작업 시작시간) - (도착 시간) 

- **P1**: $0 - 0 = 0$
- **P2**: $30 - 3 = 27$
- **P3**: $48 - 6 = 42$

- **→ 평균 대기시간 $= (0 + 27 + 42) / 3 = 23$**

**평균 반환시간**

> (반환 시간) = (작업 종료 시간) - (도착 시간)

- **P1**: $30 - 0 = 30$
- **P2**: $48 - 3 = 45$
- **P3**: $57 - 6 = 51$

- **→ 평균 반환시간 $= (30 + 45 + 51) / 3 = 42$**




## 2. 알고리즘 종류 요약

![]({{ img_path }}/2. 알고리즘 종류 요약.png){: width='650'}
_알고리즘 종류 요약 (1)_

![]({{ img_path }}/2. 알고리즘 종류 요약 2.png){: width='650'}
_알고리즘 종류 요약 (2)_

### 2.1. FCFS(First Come First Served)
- 비선점 스케줄링
- 도착한 순서대로 스레드를 준비 큐에 넣고 **도착한 순서대로 처리**

### 2.2. SJF(Shortest Job First)
- 비선점 스케줄링
- 가장 실행시간 짧은 스레드를 우선으로 처리

### 2.3. Shortest remaining time first
- **선점 스케줄링**
- 지금 실행하는 스레드보다 남은 시간이 더 짧은 스레드가 준비 큐에 들어오면 이를 우선 처리

### 2.4. Round-robin
- **preemptive**(선제적)
- 스레드들을 돌아가면서 할당된 시간(타임 슬라이스)만큼 실행

### 2.5. Priority Scheduling
- 선점/비선점 스케줄링 **둘다 구현 가능**
- **우선 순위를 기반**으로 하는 스케줄링. 가장 높은 순위의 스레드 먼저 실행

### 2.6. Multilevel queue scheduling
- 선점/비선점 스케줄링 **둘다 구현 가능**
- 스레드와 큐 모두 n개의 우선순위 레벨로 할당, 스레드는 자신의 레벨과 동일한 큐에 삽입
- 높은 순위의 큐에서 스레드 스케줄링, 높은 순위의 큐가 빌 때 아래 순위의 큐에서 스케줄링
- 스레드는 다른 큐로 이동하지 못함
- **예)** background process, Foreground process

### 2.7. Multilevel feedback queue scheduling
- 선점/비선점 스케줄링 **둘다 구현 가능**
- 큐만 n개의 우선순위 레벨을 둠. 스레드는 레벨이 없이 동일한 우선순위
- 스레드는 제일 높은 순위의 큐에 진입하고 큐타임슬라이스가 다하면 아래 레벨의 큐로 이동
- 낮은 레벨의 큐에 오래 있으면 높은 레벨의 큐로 이동



## 3. FCFS(First Come First Served)
- **선입선출**

- 가장 단순한 형태 (큐 그 자체)
- 멎너 도착한 스레드 먼저 스케줄링

### 3.1. FCFS 스케줄링의 동작

![]({{ img_path }}/3.1. FCFS 스케줄링의 동작.png){: width='550'}

| 스레드 | 도착 시간 | 실행 시간(ms) |
| ------ | --------- | ------------- |
| T1     | 0         | 4             |
| T2     | 1         | 3             |
| T3     | 2         | 1             |
| T4     | 5         | 3             |

![]({{ img_path }}/3.1 FCFS 스케줄링의 동작.png){: width='480'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/3.1 FCFS 스케줄링의 동작 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 스레드**: 실행 중 스레드_



#### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $0$
- **T2**: $4-1=3$
- **T3**: $7-2=5$
- **T4**: $8-5=3$
- 평균 대기시간 = $(0+3+5+3)/4=2.75$

#### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $4$
- **T2**: $7-1=6$
- **T3**: $8-2=6$
- **T4**: $11-5=6$
- 평균 반환시간 = $(4+6+6+6)/4=5.5$

### 3.2. 요약

|     평가 항목     | 내용                                                       |
| :---------------: | ---------------------------------------------------------- |
| 스케줄링 파라미터 | 스레드 별 도착 시간                                        |
|   스케줄링 타입   | 비선점 스케줄링                                            |
|  스레드 우선순위  | 없음                                                       |
|       기아        | 발생 X[^FCFS-starve]                                       |
|   **성능 이슈**   | **처리율 ↓**<br>**호위 효과(convoy effect) 발생**[^convoy] |

[^FCFS-starve]: 단 한 스레드가 오류로 인해 무한 루프가 발생(실행시간 → $\inf$)하면 뒤 스레드의 기아 발생
[^convoy]: 긴 스레드가 CPU 오래 사용 시, 늦게 도착한 스레드는 오래 대기




## 4. SJF(Shortest Job First)

- 최단 작업 우선 스케줄링
- 예상 실행 시간이 가장 짧은 스레드를 선택
- 스레드 도착 시, 예상 실행 시간 짧은 순으로 큐에 삽입 후 큐의 맨 앞에 있는 스레드 선택
- 실행중인 스레드보다 더 실행시간 짧은 스레드가 들어와도 현재 스레드는 중단되지 않고 계속 실행됨

### 4.1. SJF 스케줄링의 동작

![]({{ img_path }}/4.1. SJF 스케줄링의 동작.png){: width='400'}

---

#### **Case 1**
{: data-toc-skip=''}

| 스레드 | 도착 시간 | 실행 시간(ms) |
| ------ | --------- | ------------- |
| T1     | 0         | 4             |
| T2     | 1         | 3             |
| T3     | 2         | 1             |
| T4     | 5         | 3             |

![alt text]({{ img_path }}/4.1. Case 1.png){: width='480'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/4.1. Case 1 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미이다._

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $0$
- **T2**: $5-1=4$
- **T3**: $4-2=2$
- **T4**: $8-5=3$
- 평균 대기시간 = $(0+4+2+3)/4=2.25$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $4$
- **T2**: $8-1=7$
- **T3**: $5-2=3$
- **T4**: $11-5=6$
- 평균 반환시간 = $(4+7+3+6)/4=5$

---

#### **Case 2**
{: data-toc-skip=''}

| 스레드 | 도착 시간 | CPU burst 시간 |
| ------ | --------- | -------------- |
| T1     | 0         | 14             |
| T2     | 4         | 8              |
| T3     | 8         | 2              |
| T4     | 10        | 8              |

![]({{ img_path }}/4.1. Case 2.png){: width='550'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/4.1. Case 2 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미이다._

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $0$
- **T2**: $16-4=12$
- **T3**: $14-8=6$
- **T4**: $24-10=14$
- 평균 대기시간 = $(0+12+6+14)/4=8$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $14$
- **T2**: $24-4=20$
- **T3**: $16-8=8$
- **T4**: $32-10=22$
- 평균 반환시간 = $(14+20+8+22)/4=16$

---

### 4.2. 요약

|     평가 항목     | 내용                                         |
| :---------------: | -------------------------------------------- |
| 스케줄링 파라미터 | 스레드별 예상 실행 시간(남은 실행 시간)      |
|   스케줄링 타입   | 비선점 스케줄링[^SJF-type]                   |
|  스레드 우선순위  | 없음                                         |
|       기아        | 발생 가능[^SJF-starve]                       |
|   **성능 이슈**   | 짧은 스레드 먼저 실행 → 평균 대기시간 최소화 |

[^SJF-type]: **하지만 선점도 가능**한데, 이 경우는 **SRTF(Shortest Remaining Time First)** 알고리즘이 된다.
[^SJF-starve]: 지속적으로 짧은 스레드 도착 시, 긴 스레드는 언제 실행 기회 얻을 지 예측 불가능하다.

### 4.3. 문제점
- **실행 시간의 예측이 불가능**하기 때문에 현실에서 거의 사용되지 않음



## 5. SRTF(Shortest Remaining Time First)

- **가장 짧은 실행시간**을 우선하는 스케줄링
- **SJF 스케줄링의 선점 방식 버전**이라 할 수 있음
- 실행중인 스레드보다 더 실행시간 짧은 스레드가 들어오면 현재 스레드를 중단하고 그 스레드를 실행

#### **Case 1**
{: data-toc-skip=''}

| 스레드 | 도착 시간 | 실행 시간(ms) |
| ------ | --------- | ------------- |
| T1     | 0         | 4             |
| T2     | 1         | 3             |
| T3     | 2         | 1             |
| T4     | 5         | 3             |

![]({{ img_path }}/5. Case 1.png){: width='550'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/5. Case 1 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 스레드**: 실행 중 스레드_

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $(0-0) + (3-2) = 1$
- **T2**: $(5-1) = 4$
- **T3**: $(2-2) = 0$
- **T4**: $(8-5)=3$
- 평균 대기시간 = $(1+4+0+3)/4=2$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $5-0=5$
- **T2**: $8-1=7$
- **T3**: $3-2=1$
- **T4**: $11-5=6$
- 평균 반환시간 = $(5+7+1+6)/4=4.75$

#### **Case 2**
{: data-toc-skip=''}

| 스레드 | 도착 시간 | CPU burst 시간 |
| ------ | --------- | -------------- |
| T1     | 0         | 14             |
| T2     | 4         | 8              |
| T3     | 8         | 2              |
| T4     | 10        | 8              |

![]({{ img_path }}/5. Case 2.png){: width='450'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/5. Case 2 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 스레드**: 실행 중 스레드_

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $(0-0) + (22-4) = 18$
- **T2**: $(4-4) + (10-8) = 2$
- **T3**: $(8-8) = 0$
- **T4**: $(14-10) = 4$
- 평균 대기시간 = $(18+2+0+4)/4=6$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $32-0=32$
- **T2**: $14-4=10$
- **T3**: $10-8=2$
- **T4**: $22-10=12$
- 평균 반환시간 = $(32+10+2+12)/4=14$

### 5.1. 요약

|     평가 항목     | 내용                                    |
| :---------------: | --------------------------------------- |
| 스케줄링 파라미터 | 스레드별 예상 실행 시간(남은 실행 시간) |
|   스케줄링 타입   | **선점 스케줄링**                       |
|       기아        | 발생 가능[^SRTF-starve]                 |

[^SRTF-starve]: SJF와 마찬가지로 짧은 스레드가 계속 들어오면 기아 발생이 가능함



## 6. Round-robin(RR, 라운드 로빈)

- 스레드에게 공평한 실행 기회 주기 위해 큐에 대기 중 **스레드들을 타임 슬라이스 주기로 돌아가면서 선택**
- 도착 순서대로 스레드들을 큐에 삽입
- 타임 슬라이스 지나면 큐 끝으로 이동

### 6.1. Round-robin의 동작

![]({{ img_path }}/6.1. Round-robin의 동작.png){: width='450'}

---

#### **Case 1**
{: data-toc-skip=''}

| 스레드 | 도착 시간 | 실행 시간(ms) |
| ------ | --------- | ------------- |
| T1     | 0         | 4             |
| T2     | 1         | 3             |
| T3     | 2         | 1             |
| T4     | 5         | 3             |

#### 1) Time slice가 2ms인 경우
{: data-toc-skip=''}

![]({{ img_path }}/6.1. Case 1 2ms.png){: width='450'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/6.1. Case 1 2ms 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 스레드**: 실행 중 스레드_

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $(0-0) + (5-2) = 3$
- **T2**: $(2-1) + (7-4) = 4$
- **T3**: $(4-2) = 2$
- **T4**: $(8-5) = 3$
- 평균 대기시간 = $(3+4+2+3)/4=3$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $7-0=7$
- **T2**: $8-1=7$
- **T3**: $5-2=3$
- **T4**: $11-6=6$
- 평균 반환시간 = $(7+7+3+6)/4=5.75$

---

#### 2) Time slice가 1ms인 경우
{: data-toc-skip=''}

![]({{ img_path }}/6.1. Case 1 1ms.png){: width='450'}
_**직사각형 속 스레드**: 실행중 스레드<br>**수직선 밑 스레드**: 그 스레드의 도착 시간_

![]({{ img_path }}/6.1. Case 1 1ms 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 스레드의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 스레드**: 실행 중 스레드_

##### **평균 대기 시간**
{: data-toc-skip=''}

- **T1**: $0+1+2+2 = 5$
- **T2**: $0+2+2 = 4$
- **T3**: $1$
- **T4**: $1+2 = 3$
- 평균 대기시간 = $(5+4+1+3)/4=3.25$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **T1**: $9-0=9$
- **T2**: $8-1=7$
- **T3**: $4-2=2$
- **T4**: $11-5=6$
- 평균 반환시간 = $(9+7+2+6)/4=6$

---

#### **Case 2** 
{: data-toc-skip=''}

- Time slice가 10ms인 경우

| 도착 순서 | 도착 시간 | 작업 시간 |
| --------- | --------- | --------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

![]({{ img_path }}/6.1. Case 2.png){: width='550'}
_**직사각형 속 프로세스**: 실행중 프로세스<br>**수직선 밑 프로세스**: 그 프로세스의 도착 시간_

![]({{ img_path }}/6.1. Case 2 큐.png){: width='400'}
_$\mathrm{T}n(k)$ = $n$번 프로세스의 남은 실행 시간은 $k$라는 의미<br>**큐 맨 왼쪽 프로세스**: 실행 중 프로세스_

##### **평균 대기 시간**
{: data-toc-skip=''}

- **P1**: $0 + (29-10) + (47-39) = 27$
- **P2**: $(10-3) + (39-20) = 26$
- **P3**: $20-6=14$
- 평균 대기시간 = $(27+26+14)/3=22.33$

##### **평균 반환 시간**
{: data-toc-skip=''}

- **P1**: $57-0=57$
- **P2**: $47-3=44$
- **P3**: $29-6=23$
- 평균 반환시간 = $(57+44+23)/4=41.33$

---

### 6.2. 요약

|     평가 항목     | 내용              |
| :---------------: | ----------------- |
| 스케줄링 파라미터 | 타임 슬라이스     |
|   스케줄링 타입   | **선점 스케줄링** |
|  스레드 우선순위  | 없음              |
|       기아        | 없음[^RR-starve]  |

![]({{ img_path }}/6.2. 타임슬라이스와 문맥 교환 관계.png){: width='550'}

[^RR-starve]: 스레드 우선순위가 없고, 타임 슬라이스가 정해져 있으므로 일정 시간 후에 스레드는 반드시 실행된다.

### 6.3. 성능 이슈

- 공평하고, 기아 현상 없고, 구현 쉬움
- 잦은 스케줄링으로 전체 스케줄링 오버헤드 ↑
  - **특히 타임슬라이스 작은 경우 더 커짐**
- 균형된 처리율
  - **타임 슬라이스 크기 ↑**: FCFS에 가까움
  - **타임 슬라이스 크기 ↓**: SJF/SRTF에 가까움
- **늦게 도착한 짧은 프로세스**: FCFS보다 빨리 완료됨
- **긴 프로세스**: SJF보다 빨리 완료됨



## 7. 우선순위(Priority)

- **우선순위**에 따라 스레드를 실행
- 가장 높은 우선순위의 스레드 선택
- **현재 스레드가 종료**되거나 **더 높은 순위의 스레드가 도착**할 때, 가장 높은 순위의 스레드 선택
- 도착하는 스레드는 **우선순위 순으로 큐에 삽입**된다.

### 7.1. 고정 순위 알고리즘

- 한 번 우선순위를 부여받으면 종료때까지 **우선순위 고정**
- 단순히 구현 가능하지만, 시시각각 변하는 시스템 상황 반형 X → **효율성↓**

### 7.2. 변동 우선순위 알고리즘

- 일정 시간마다 우선순위 변하여 **일정시간마다 우선순위 새로 계산/반영**
- 복잡하지만, 시스템 상황 반영해 **효율적인 운영** 가능

### 7.3. 예시

| 도착 순서 | 도착 시간 | 작업 시간 | 우선 순위 |
| --------- | --------- | --------- | --------- |
| P1        | 0         | 30        | 3         |
| P2        | 3         | 18        | 2         |
| P3        | 6         | 9         | 1         |

- 비선점 평균 대기 시간: 20
- 선점 평균 대기 시간: 

(내용 추가예정)

### 7.4. 요약

|     평가 항목     | 내용                                                            |
| :---------------: | --------------------------------------------------------------- |
| 스케줄링 파라미터 | 스레드 별 고정 우선순위                                         |
|   스케줄링 타입   | **선점/비선점 스케줄링**                                        |
|  스레드 우선순위  | **있음**                                                        |
|       기아        | 발생 가능                                                       |
|     성능 이슈     | 높은 우선순위일수록 대기/응답시간 짧음<br>Real-time OS에서 유리 |

- 스케줄링 타입
  - **선점 스케줄링**인 경우: 더 높은 스레드가 도착할 때 현제 스레드 강제 중단 후 스케줄링
  - **비선점 스케줄링**인 경우: 현재 실행 중인 스레드가 종료될 때 비로소 스케줄링

- 기아
  - 지속적으로 높위 스레드 도착하는 경우, 언제 실행 기회 얻을 지 예상 불가
  - 큐 대기시간에 비례, 일시적으로 우선순위 높이는 에이징 방법으로 해결 가능



## 8. HRN 스케줄링(Highest Response ratio Next)

- **기아현상을 완화**하기 위해 만들어진 알고리즘
  - SJF의 변형
- 서비스 받기 위해 기다린 시간과 CPU 사용시간 고려해 스케줄링 하는 방식

$$\mathrm{우선순위} = \frac{ \mathrm{대기시간} + \mathrm{CPU 사용시간} }{ \mathrm{CPU 사용시간} }$$

### 8.1. 예시

#### **Case 1**
{: data-toc-skip=''}

| 작업 | 대기 시간 | 서비스 시간 |
| ---- | --------- | ----------- |
| A    | 5         | 20          |
| B    | 40        | 20          |
| C    | 15        | 45          |
| D    | 20        | 20          |

(내용 추가예정)

#### **Case 2**
{: data-toc-skip=''}

| 도착 순서 | 도착 시간 | 작업 시간 |
| --------- | --------- | --------- |
| P1        | 0         | 30        |
| P2        | 3         | 18        |
| P3        | 6         | 9         |

- 평균 대기 시간: 계산 필요
(내용 추가예정)

### 8.2. 요약

|     평가 항목     | 내용                                 |
| :---------------: | ------------------------------------ |
| 스케줄링 파라미터 | 스레드 별 작업시간 + 대기시간        |
|   스케줄링 타입   | **비선점 스케줄링**[^HRN-type]       |
|  스레드 우선순위  | **있음**                             |
|       기아        | 발생 낮음[^HRN-starve]               |
|     성능 이슈     | 대기시간 긴 스레드일 수록 우선순위 ↑ |

[^HRN-type]: 선점일 경우 핑퐁핑퐁핑퐁
[^HRN-starve]: 알고리즘에 의해 거의 발생하지 않지만, 여전히 공평하다고는 말하기 어려움



## 9. MLQ(Multi-level Queue)

(내용 추가예정)



## 10. MLFQ(Multi-level Feedback Queue)

(내용 추가예정)



## 11. 멀티코어 CPU 스케줄링

![]({{ img_path }}/11. 멀티코어 CPU 스케줄링.png){: width='650'}
_멀티코어 CPU 스케줄링의 예_

### 11.1. 문제점

(내용 추가예정)

### 11.2. 해결책

(내용 추가 예정)

## 11.3. 생각해볼 거리

(내용 추가 예정)



<br><br><br><br>

---
#### 각주
{: data-toc-skip=''}