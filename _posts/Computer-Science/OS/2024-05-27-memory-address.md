---
title: "[OS] 메모리 주소"
date: 2024-05-27 09:05:00 +0900
categories: [Computer-Science, OS]
tags: ['OS', '메모리']
---



## 1. 물리 주소, 논리 주소

- 메모리는 오직 주소로만 접근할 수 있음

### 1.1. 물리 주소(physical address) 

- 하드웨어 관점
- 물리 메모리(RAM)에 매겨진 주소, 하드웨어에 의해 고정된 메모리 주소
- 0에서 시작하여 연속되는 주소 체계
- 메모리는 시스템 주소 버스를 통해 물리 주소의 신호 받음

### 1.2. 논리/가상 주소(logical address/virtual address) 

- 프로세스 관점
- 개발자나 프로세스가, 프로세스 내에서 사용하는 주소, 코드나 변수 등에 대한 주소
- CPU가 프로세스를 실행하는 동안 다루는 모든 주소는 논리 주소
- 프로세스 내에서 매겨진 상대 주소 ~ 0에서 시작하여 연속되는 주소 체계
  - 프로그램에서 변수 n의 주소가 100번지라면, 논리 주소가 100이고, 물리 주소를 알 수 없음, 실제 메모리의 주소 아님
- 컴파일러와 링커에 의해 매겨진 주소
  - 실행 파일에 내에 만들어진 이진 프로그램의 주소들은 논리 주소로 되어 있음
- 사용자나 프로세스는 결코 물리 주소를 알 수 없음
- 메모리 접근 시 상대 주소를 사용하면 **절대 주소**로 변환해야 함 → MMU의 개념

### 1.3. Address binding

- 프로그램이 메모리 어느 위치에, 즉 어떤 물리적 위치에 Load될지 경정하는 과정
  - **Compile-time binding**: 프로세스의 물리적 주소가 컴파일 타임에 정해짐
    - 물리주소 == 논리주소 → 같은 주소를 쓰는 프로세스가 있다면?? 적재 불가능. 매우 비효율
  - **Load-time binding**: Loader가 프로세스를 load 하는 시점에 물리적 주소 결정 (Relocatable)
    - 바꿔야할 주소가 많다면? 로딩에 부담!
  - **Run-time binding**: 프로세스가 수행이 시작된 이후에 프로세스가 실행될 때 메모리 주소를 바꿈
    - Runtime때 물리적 주소가 결정
    - **MMU(Memory Management Unit)**

{% assign img_path = "/assets/img/posts/OS/2024-05-27-memory-address" %}
![1.3. address binding]({{ img_path }}/1.3. address binding.png){: width='500'}



## 2. MMU(Memory Management Unit)

- 논리 주소를 물리주소로 바꾸는 하드웨어 장치
  - CPU가 발생시킨 논리 주소는 MMU에 의해 물리 주소로 바뀌어 메모리에 도달
- 오늘날 MMU는 CPU 안에 내장되어 있음
  - 인텔이나 AMD의 x86 CPU는 80286부터 MMU를 내장함
  - MMU 덕분으로, 여러 프로세스가 하나의 메모리에서 실행되도록 되었음

![2. MMU 1]({{ img_path }}/2. MMU 1.png){: width='500'}

![2. MMU 2]({{ img_path }}/2. MMU 2.png)

### 2.1. 상대주소에서 물리주소로의 변환

- 메모리 관리자는 사용자 프로세스가 상대 주소를 사용하여 메모리에 접근할 때마다 상대 주소값에 Base 레지스터 값을 더하여 절대 주소를 구함
- **Base 레지스터**
  - 주소 변환의 기본이 되는 주소값을 가진 레지스터
  - 메모리에서 사용자 영역의 시작 주소값이 저장 (접근할 수 있는 물리적 주소의 최소값)
- **Limit 레지스터**
  - 메모리 관리자는 사용자가 작업을 요청할 때마다 경계 (상한)을 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료

| 구분      | 절대 주소                 | 상대 주소                                |
| --------- | ------------------------- | ---------------------------------------- |
| 관점      | 메모리 관리자 입장        | 사용자 프로세스 입장                     |
| 주소 시작 | 물리 주소 0번지부터 시작  | 물리주소와 관계 없이 항상 0번지부터 시작 |
| 주소 공간 | 물리 주소(실제 주소) 공간 | 논리 주소 공간                           |

![2.1 상대주소 절대주소 1]({{ img_path }}/2.1 상대주소 절대주소 1.png){: width='500'}



## 3. 주소 변환

- 프로세스의 모든 코드들은 논리 주소로 구성
- CPU가 읽고 해석하고 발생시키는 주소는 모두 **논리 주소**
- **논리 주소**와 **물리 주소**의 매핑 테이블 있음
- MMU를 거쳐 논리주소가 물리 주소로 바뀌어 출력
- MMU는 매핑 테이블을 이용하여 주소 변환

![3. 주소 변환]({{ img_path }}/3. 주소 변환.png)



## 4. 메모리 오버레이

- **가상 메모리 공간**
  - 각 프로세스는 자신이 모든 메모리를 점유하고 있는 것 처럼 생각한다.
  - 실제 할당된 공간은 작음
    - 프로세스가 실제 필요한 공간보다 물리공간이 더 작을 수 있음.

- **메모리 오버레이**
  - 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법
  - 프로그램이 실행되면 현재 필요한 부분만 메모리에 올라와 실행 → **바꿔가면서 (Swap)**
  - 한정된 메모리에서 메모리보다 큰 프로그램 실행 가능
  - 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행 가능

![4. 메모리 오버레이]({{ img_path }}/4. 메모리 오버레이.png){: width='500'}

### 4.1. Swap

- **Swap area**
  - 메모리가 모자라서 쫓겨난 프로세스를 저장장치의 특별한 공간에 모아두는 영역
  - 메모리에서 쫓겨났다가 다시 돌아가는 데이터가 머무는 곳이기 때문에 저장장치는 장소만 빌려주고 메모리 관리자가 관리
  - 사용자는 실제 메모리의 크기와 스왑 영역의 크기를 합쳐서 전체 메모리로 인식하고 사용

- **Swap in, swap out**
  - 빈번하게 왔다갔다 단편화 문제 발생 → 성능 문제

- 윈도우에서는 **가상메모리**라고 표현
  - pagefile.sys, swapfile.sys 등 파일로 저장함
- 리눅스에서는 스**왑파티션**이라고 표현함

![4.1. swap]({{ img_path }}/4.1. swap.png){: width='500'}



## 5. 메모리 보호 기법

- CPU는 사용자 모드에서 생성된 모든 메모리 액세스를 확인하여 해당 사용자의 기본값과 제한값 사이에 있는지 확인해야 함
  - 하드웨어(MMU)의 지원을 받음
- 프로세스의 논리적 주소 공간을 정의하는 **Base register**와 **Limit register**를 사용하여 접근 보호 기능
  - 이들을 벗어나는 주소 공간을 접근하면 에러 발생

![5. 메모리 보호 기법]({{ img_path }}/5. 메모리 보호 기법.png){: width='500'}

### 5.1. ASLR

- **ASLR(Address Space Layout Randomization)**라고 함
- 메모리 주소가 누출되는 일은 보안상 매우 위험한 일!
  - 임의의 코드 실행 → 그 코드가 system 함수라면? → 뭐든 다 할 수 있다.

- **주소 공간의 랜덤 배치**
  - 프로세스의 주소 공간 내에서 스택이나 힙, 라이브러리 영역의 랜덤 배치
  - 직접적인 메모리 참조가 힘들어짐
    - 실행할 때마다 이들의 논리 주소가 바뀌게 하는 기법.
  - 실행할 때마다 함수의 지역 변수와 동적 할당 받는 메모리의 논리 주소가 바뀜

![5.1. ASLR]({{ img_path }}/5.1. ASLR.png){: width='500'}